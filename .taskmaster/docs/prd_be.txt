<context>
# Overview  
This MVP focuses purely on the **backend and database** for a web application that connects **employers (người thuê)** with **workers (người làm việc)** for task-based jobs.  
The system solves the problem of **finding, vetting, and coordinating local workers** for small jobs by providing structured flows for posting jobs, applying, approving, tracking status, reviewing, and handling disputes.  
It targets three main personas: **Employers** who post jobs, **Workers** who search and apply for jobs, and **Admins** who moderate content, verify certificates, and resolve complaints.  
The value of this backend MVP is to prove that the **core end‑to‑end workflow** can run reliably on a local environment: đăng việc → nhận việc → hoàn thành → đánh giá / khiếu nại, with clear state transitions and auditability, while being simple enough to implement and test quickly.

# Core Features  
- **Authentication & User Management (Employer / Worker / Admin)**  
  - **What it does**: Supports registration and login for all three roles, secure credential storage, and role-based access control.  
  - **Why it's important**: Every other feature depends on authenticated actors; roles enforce which APIs each user can call (e.g., only Admin can approve certificates).  
  - **How it works**: 
    - Users register via dedicated endpoints for employer and worker, providing phone, password, and basic profile information.  
    - Passwords are stored as hashes in the `users` table; roles are managed via `roles` and `user_roles`.  
    - Upon login, backend issues a **JWT access token** with embedded user id and role; each protected endpoint validates the token and enforces role checks.

- **Job Posting & Management (Employer)**  
  - **What it does**: Allows employers to create, view, update, and cancel job postings, as well as associate images with jobs.  
  - **Why it's important**: Job postings are the central object in the system; without them, there is nothing for workers to discover or apply to.  
  - **How it works**: 
    - CRUD operations operate on the `jobs` and `job_images` tables.  
    - Business rules enforce that jobs can only be edited or deleted while in `CHUA_LAM` and before any worker is accepted.  
    - Jobs track status (`CHUA_LAM`, `DANG_BAN_GIAO`, `DA_XONG`) and relationships to employers and accepted workers.

- **Job Discovery & Application (Worker)**  
  - **What it does**: Allows workers to browse open jobs and send applications to specific jobs.  
  - **Why it's important**: This is the core interaction for workers, enabling them to find relevant tasks and express interest.  
  - **How it works**: 
    - Workers query `jobs` with filters to retrieve only open jobs (excluding `DA_XONG`).  
    - Applying to a job creates entries in `job_applications`, enforcing uniqueness per `(job_id, worker_id)`.  
    - Workers can later see outcomes via status fields and notifications.

- **Worker Verification via Certificates**  
  - **What it does**: Lets workers submit professional certificates for verification and lets admins approve or reject them.  
  - **Why it's important**: Introduces a **trust layer**—employers can rely on verified workers; admin oversight reduces fraud.  
  - **How it works**: 
    - Workers upload certificate metadata (image URL) via API; backend stores in `worker_certificates` with `PENDING` status.  
    - Admin APIs list pending certificates and update them to `APPROVED` or `REJECTED`, populating `reviewed_by` and `reviewed_at`.  
    - `worker_profiles.is_verified` is updated accordingly and can be used by future features like filters or ranking.

- **Worker Selection & Job State Management**  
  - **What it does**: Enables employers to review applicants, accept or reject workers, and drive jobs through the lifecycle from open to in-progress to done or reset.  
  - **Why it's important**: Ensures there is a **single accepted worker** per job and that job states are consistent and traceable.  
  - **How it works**: 
    - Employers list applications per job, inspect worker profiles, and call accept/reject APIs.  
    - Accepting a worker updates `job_applications.status` and sets `jobs.accepted_worker_id` while enforcing only one accepted worker per job.  
    - State changes (e.g., complete or reset) are recorded both in the `jobs.status` field and in `job_status_logs` for audit.

- **Rating & Review of Workers**  
  - **What it does**: Lets employers rate workers and leave comments after a job is completed.  
  - **Why it's important**: Captures long‑term reputation and quality signals, influencing future employer decisions and worker behavior.  
  - **How it works**: 
    - After job completion, employers create a single review per job in `worker_reviews`, constrained by a unique `(job_id)` rule.  
    - The system can aggregate review scores into `worker_profiles.avg_rating` (MVP can compute lazily or via simple queries).

- **Complaints & Admin Resolution**  
  - **What it does**: Allows users to file complaints about jobs and empowers admins to review evidence and make binding decisions.  
  - **Why it's important**: Provides a **formal dispute mechanism** when work outcomes are contested, essential for trust and safety.  
  - **How it works**: 
    - Complaints are stored in `complaints` with links to `jobs` and `created_by`.  
    - Evidence (e.g., image URLs or logs) is attached via `complaint_evidences`.  
    - Admin APIs load complaint details, inspect history, and mark them `RESOLVED` with a decision (`ACCEPT`/`REJECT`), recording `resolved_by` and `resolved_at`.

- **Notifications & System Tasks**  
  - **What it does**: Stores and serves user-facing notifications (e.g., application accepted, job status changed) and exposes a system endpoint for batch job housekeeping.  
  - **Why it's important**: Keeps participants informed about important changes and provides a hook for periodic maintenance tasks.  
  - **How it works**: 
    - New events (e.g., application result, complaint resolution) insert rows into `notifications`.  
    - Users query their unread or recent notifications via a simple API.  
    - A system API (`/api/system/jobs/expire-handover`) can be invoked by a scheduler (out of scope for MVP) or manually to process overdue jobs based on deadlines.

# User Experience  
*(Backend-only scope: this section describes logical journeys and expectations as seen through APIs, not UI design.)*

- **User personas**  
  - **Employer (Người thuê)**: Wants to quickly post jobs, choose reliable workers, track progress, and leave reviews or complaints when necessary. Interacts with auth, job management, applications list, status, review, and complaint APIs.  
  - **Worker (Người làm việc)**: Wants to discover jobs that match their skills, apply efficiently, get hired, complete tasks, and build a positive rating and verification status. Interacts with auth, profile, certificate, job listing, apply, and status APIs.  
  - **Admin**: Oversees data quality and trust by moderating job posts, verifying worker certificates, monitoring job states, and resolving disputes. Uses admin job, certificate, and complaint APIs.

- **Key user flows**  
  - **Employer flow (end-to-end)**:  
    1. Registers and logs in as Employer.  
    2. Creates a job (`POST /api/jobs`) including required skills and (optionally) image URLs.  
    3. Waits for admin approval if required and then for worker applications.  
    4. Reviews applicants (`GET /api/jobs/{jobId}/applications`) and accepts a single worker.  
    5. Confirms completion (`POST /api/jobs/{jobId}/complete`) or resets to "Chưa làm" if unsatisfactory.  
    6. Leaves a review for the worker.  
    7. Optionally files a complaint if there is a dispute.
  - **Worker flow (end-to-end)**:  
    1. Registers and logs in as Worker.  
    2. Updates profile and optionally submits certificates for verification.  
    3. Browses open jobs (`GET /api/jobs`) and views details.  
    4. Applies to selected jobs (`POST /api/jobs/{jobId}/apply`).  
    5. Receives notification when accepted or rejected.  
    6. Completes the job and sees final status and review.  
  - **Admin flow**:  
    1. Logs in with Admin credentials.  
    2. Reviews pending jobs for appropriateness and either approves or rejects.  
    3. Reviews worker certificates and sets them to approved or rejected.  
    4. Monitors job statuses and intervenes when necessary (e.g., inconsistent states).  
    5. Handles complaints by reviewing evidence and issuing decisions.

- **API/UX considerations (backend)**  
  - APIs are **RESTful**, with clear resource naming and use of HTTP verbs.  
  - Error responses are consistent (e.g., structured JSON with code and message) to support a future frontend.  
  - Authentication is stateless via JWT, reducing coupling between clients and server-side sessions.  
  - All time fields are stored as timestamps (Unix or DB TIMESTAMP), enabling deterministic behavior across environments.
</context>
<PRD>
# Technical Architecture  
- **System components**  
  - **Backend service**: A single Node.js + Express application exposing REST APIs for auth, jobs, applications, reviews, complaints, notifications, and admin operations.  
  - **Database layer**: A single **SQLite** database file accessed via `better-sqlite3`, with tables normalized to (approximately) 3NF.  
  - **Static asset serving**: A simple static file route (e.g., `/static/*`) that serves local image files such as certificate scans from the host filesystem.  
  - **Testing harness**: Jest + Supertest integration tests that exercise the API end-to-end against the same SQLite schema.  
  - **API documentation**: A Swagger UI instance powered by an OpenAPI 3.0 YAML spec file.

- **Data models**  
  - **User & Auth domain**:  
    - `roles`: contains role definitions (`EMPLOYER`, `WORKER`, `ADMIN`).  
    - `users`: stores core identity and credentials (phone, password hash, full name, address, timestamps).  
    - `user_roles`: links users to roles, with a composite primary key `(user_id, role_id)`; MVP expects exactly one role per user.  
  - **Profiles & Verification**:  
    - `employer_profiles`: employer-specific info (e.g., activity score, reserved for future engagement metrics).  
    - `worker_profiles`: worker-specific info such as skills, average rating, and `is_verified` flag.  
    - `worker_certificates`: certificate submissions with `image_url`, `status` (`PENDING`, `APPROVED`, `REJECTED`), and admin review metadata.  
  - **Job & Application domain**:  
    - `jobs`: central job listing entity, referencing employer, accepted worker (optional), address, price, required skill, and status (`CHUA_LAM`, `DANG_BAN_GIAO`, `DA_XONG`).  
    - `job_images`: optional job-related images, storing only `image_url` and a boolean `is_primary`.  
    - `job_applications`: links workers to jobs with `status` (`APPLIED`, `ACCEPTED`, `REJECTED`), enforcing uniqueness per `(job_id, worker_id)`.  
    - `job_status_logs`: captures job state transitions with `old_status`, `new_status`, who changed it, and when.  
  - **Review & Complaints**:  
    - `worker_reviews`: single review per job (unique by `job_id`), connecting employer, worker, and rating info.  
    - `complaints` and `complaint_evidences`: represent disputes and their supporting evidence, with fields for status and admin resolution data.  
  - **System**:  
    - `notifications`: simple notification messages for users, including `is_read` and timestamps.

- **APIs and integrations**  
  - **Auth / Account APIs**:  
    - Registration: `POST /api/auth/register-employer`, `POST /api/auth/register-worker`.  
    - Login/Logout: `POST /api/auth/login`, `POST /api/auth/logout`.  
    - Profile: `GET /api/users/me`, `PUT /api/users/me`.  
    - All authenticated routes require `Authorization: Bearer <token>` with a valid JWT.
  - **Worker certificate APIs**:  
    - `POST /api/workers/certificates` to submit certificates with `image_url` referencing a static asset.  
    - `GET /api/workers/certificates/status` to check verification status.  
    - Admin endpoints for listing and approving/rejecting certificates.  
  - **Job and application APIs**:  
    - Employer job management: `POST /api/jobs`, `GET /api/jobs/my`, `GET /api/jobs/{jobId}`, `PUT /api/jobs/{jobId}`, `DELETE /api/jobs/{jobId}`.  
    - Worker job discovery: `GET /api/jobs` with query filters.  
    - Application management: `POST /api/jobs/{jobId}/apply`, `GET /api/jobs/{jobId}/applications`, `POST /api/jobs/{jobId}/accept/{workerId}`, `POST /api/jobs/{jobId}/reject/{workerId}`.  
    - Status operations: `GET /api/jobs/{jobId}/status`, `POST /api/jobs/{jobId}/complete`, `POST /api/jobs/{jobId}/reset`.  
  - **Review & complaint APIs**:  
    - Reviews: `POST /api/jobs/{jobId}/review`, `GET /api/workers/{workerId}/reviews`.  
    - Complaints: `POST /api/complaints`, `GET /api/complaints/my`.  
    - Admin complaints: list, detail, and resolve complaints via `/api/admin/complaints` endpoints.  
  - **System & notifications APIs**:  
    - `GET /api/notifications` for user notifications.  
    - `POST /api/system/jobs/expire-handover` for batch state updates on overdue jobs.  
  - **External integrations**:  
    - MVP explicitly **avoids external services** (no payment gateway, no email/SMS provider, no cloud storage, no third-party auth).

- **Infrastructure requirements**  
  - Runs entirely **on a single machine** in a local development environment.  
  - SQLite uses a **single DB file** accessible by both application and tests.  
  - No Docker, no cloud, no CI/CD required for MVP; a simple Node.js runtime (LTS) and local filesystem are sufficient.  
  - Static file directory (e.g., `./static`) must exist and be accessible to serve images referenced in DB.

# Development Roadmap  
- **Phase 1 – Backend Skeleton & Auth**  
  - Set up project scaffold: Node.js + Express structure, configuration, basic error handling, logging.  
  - Implement SQLite connection via `better-sqlite3` and bootstrap schema creation mechanism.  
  - Implement `roles`, `users`, `user_roles` tables and basic registration/login APIs with JWT issuance and middleware for authentication/authorization.  
  - Add simple `/health` endpoint for quick smoke testing.

- **Phase 2 – Core Job & Application Flows**  
  - Implement `jobs`, `job_images`, `job_applications`, and `job_status_logs` tables.  
  - Implement employer job CRUD APIs with necessary business validations (edit/delete only in allowed states).  
  - Implement worker job listing and application APIs and ensure uniqueness constraints are enforced.  
  - Implement job status management (including acceptance of a single worker and logging transitions).

- **Phase 3 – Worker Verification & Reviews**  
  - Implement `employer_profiles`, `worker_profiles`, and `worker_certificates` tables and APIs.  
  - Implement admin APIs for certificate review and keep `worker_profiles.is_verified` in sync.  
  - Implement review model and APIs, enforcing one review per job and integrating with worker rating aggregation logic.  

- **Phase 4 – Complaints, Notifications, and System Jobs**  
  - Implement `complaints` and `complaint_evidences` tables and related user/admin APIs.  
  - Implement `notifications` model and APIs, integrated with key events (application result, complaint resolution, etc.).  
  - Implement `/api/system/jobs/expire-handover` for overdue job handling and wire any necessary job state logic.  

- **Phase 5 – Testing, Swagger, and Hardening**  
  - Write integration tests (Jest + Supertest) for all core flows: auth, job posting, applying, accepting, completion, review, complaint.  
  - Create OpenAPI 3.0 YAML spec covering all MVP endpoints, security schemes, and example payloads; integrate Swagger UI.  
  - Refine error handling, input validation, and security checks (e.g., ownership checks, role enforcement) across endpoints.  
  - Perform manual local testing using Swagger UI to validate all happy-path flows.

# Logical Dependency Chain  
- **Foundational layer**  
  - Project structure and configuration must exist before any feature-specific code.  
  - Database connection and base schema (users, roles) must be in place before auth and any role-based logic.  
  - Auth (JWT issuance, middleware) must be implemented before protecting job, review, and complaint APIs.

- **Business domain layers**  
  - **Jobs & applications** depend on existing users and roles; job CRUD and application endpoints are built after auth.  
  - **Job status logs** depend on jobs; any transitions or admin interventions rely on that layer.  
  - **Worker verification** builds atop worker profiles and user roles; admin certificate processing depends on basic admin auth.  
  - **Reviews** depend on jobs being completed and a worker being accepted; they are implemented after job lifecycle logic.  
  - **Complaints and notifications** depend on jobs, users, and core flows already functioning, as they reference those entities.

- **Backend-centric priority**  
  - Prioritize achieving a **complete backend E2E path** from job posting to completion and review before adding complaint resolution or notifications.  
  - Design each feature as an **atomic module** (auth, jobs, applications, reviews, complaints, notifications) with clear boundaries so future enhancements (e.g., payments, realtime chat, advanced analytics) can hook in without rewriting core logic.

# Risks and Mitigations  
- **Technical challenges**  
  - **State machine complexity for jobs and applications**: Incorrect transitions could lead to inconsistent data.  
    - *Mitigation*: Define a small, explicit set of allowed transitions and enforce them centrally in the service layer; log every change in `job_status_logs`.  
  - **Role and permission mistakes**: APIs might be exposed to wrong roles.  
    - *Mitigation*: Centralize authorization checks in middleware and write integration tests for forbidden access scenarios.  
  - **Schema evolution in SQLite**: MVP is local-only but may need future migrations.  
    - *Mitigation*: Keep schema small and clear; document tables thoroughly to ease future migration to a stronger RDBMS.

- **Figuring out the MVP that we can build upon**  
  - Scope creep into frontend, payments, or realtime features can delay completion.  
    - *Mitigation*: Strictly enforce that **this PRD is backend + DB only**; all non-essential features are explicitly deferred to later phases.  
  - Overdesigning for scale or multi-tenant scenarios.  
    - *Mitigation*: Optimize for clarity and correctness at local scale; design schema cleanly but avoid premature optimization or sharding logic.

- **Resource constraints**  
  - Limited time for extensive unit testing.  
    - *Mitigation*: Focus exclusively on **integration tests** that cover real flows and major rules; defer fine-grained unit tests.  
  - Single-environment development (local only).  
    - *Mitigation*: Use deterministic test data and a stable schema; ensure tests can reset DB state and are reproducible on any machine.

# Appendix  
- **Research findings / rationale**  
  - Relational database with normalized schema is chosen to keep strong consistency across job states, applications, reviews, and complaints.  
  - JWT-based auth is appropriate for a stateless API that may later support multiple frontends (web, mobile).  
  - SQLite is sufficient for MVP because it minimizes operational complexity while still modeling realistic production-like relational designs.

- **Technical specifications**  
  - **Backend**: Node.js (LTS) with Express.js.  
  - **Database**: SQLite via `better-sqlite3`, single DB file, timestamps for all relevant events.  
  - **Auth**: JWT (single access token, no refresh), `Authorization: Bearer <token>` header.  
  - **API style**: RESTful, documented via OpenAPI 3.0 YAML and exposed in Swagger UI.  
  - **Testing**: Jest + Supertest integration tests for all main flows; tests run against the same SQLite schema.  
  - **Non-goals for MVP**: No frontend, no payment integration, no realtime chat, no cloud infrastructure, no advanced analytics dashboards.
</PRD>
